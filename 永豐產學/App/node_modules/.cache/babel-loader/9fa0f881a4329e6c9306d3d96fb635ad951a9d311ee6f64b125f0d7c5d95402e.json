{"ast":null,"code":"/*!\n * router\n * Copyright(c) 2013 Roman Shtylman\n * Copyright(c) 2014-2022 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Module dependencies.\n * @private\n */\nconst isPromise = require('is-promise');\nconst Layer = require('./lib/layer');\nconst {\n  METHODS\n} = require('node:http');\nconst parseUrl = require('parseurl');\nconst Route = require('./lib/route');\nconst debug = require('debug')('router');\nconst deprecate = require('depd')('router');\n\n/**\n * Module variables.\n * @private\n */\n\nconst slice = Array.prototype.slice;\nconst flatten = Array.prototype.flat;\nconst methods = METHODS.map(method => method.toLowerCase());\n\n/**\n * Expose `Router`.\n */\n\nmodule.exports = Router;\n\n/**\n * Expose `Route`.\n */\n\nmodule.exports.Route = Route;\n\n/**\n * Initialize a new `Router` with the given `options`.\n *\n * @param {object} [options]\n * @return {Router} which is a callable function\n * @public\n */\n\nfunction Router(options) {\n  if (!(this instanceof Router)) {\n    return new Router(options);\n  }\n  const opts = options || {};\n  function router(req, res, next) {\n    router.handle(req, res, next);\n  }\n\n  // inherit from the correct prototype\n  Object.setPrototypeOf(router, this);\n  router.caseSensitive = opts.caseSensitive;\n  router.mergeParams = opts.mergeParams;\n  router.params = {};\n  router.strict = opts.strict;\n  router.stack = [];\n  return router;\n}\n\n/**\n * Router prototype inherits from a Function.\n */\n\n/* istanbul ignore next */\nRouter.prototype = function () {};\n\n/**\n * Map the given param placeholder `name`(s) to the given callback.\n *\n * Parameter mapping is used to provide pre-conditions to routes\n * which use normalized placeholders. For example a _:user_id_ parameter\n * could automatically load a user's information from the database without\n * any additional code.\n *\n * The callback uses the same signature as middleware, the only difference\n * being that the value of the placeholder is passed, in this case the _id_\n * of the user. Once the `next()` function is invoked, just like middleware\n * it will continue on to execute the route, or subsequent parameter functions.\n *\n * Just like in middleware, you must either respond to the request or call next\n * to avoid stalling the request.\n *\n *  router.param('user_id', function(req, res, next, id){\n *    User.find(id, function(err, user){\n *      if (err) {\n *        return next(err)\n *      } else if (!user) {\n *        return next(new Error('failed to load user'))\n *      }\n *      req.user = user\n *      next()\n *    })\n *  })\n *\n * @param {string} name\n * @param {function} fn\n * @public\n */\n\nRouter.prototype.param = function param(name, fn) {\n  if (!name) {\n    throw new TypeError('argument name is required');\n  }\n  if (typeof name !== 'string') {\n    throw new TypeError('argument name must be a string');\n  }\n  if (!fn) {\n    throw new TypeError('argument fn is required');\n  }\n  if (typeof fn !== 'function') {\n    throw new TypeError('argument fn must be a function');\n  }\n  let params = this.params[name];\n  if (!params) {\n    params = this.params[name] = [];\n  }\n  params.push(fn);\n  return this;\n};\n\n/**\n * Dispatch a req, res into the router.\n *\n * @private\n */\n\nRouter.prototype.handle = function handle(req, res, callback) {\n  if (!callback) {\n    throw new TypeError('argument callback is required');\n  }\n  debug('dispatching %s %s', req.method, req.url);\n  let idx = 0;\n  let methods;\n  const protohost = getProtohost(req.url) || '';\n  let removed = '';\n  const self = this;\n  let slashAdded = false;\n  let sync = 0;\n  const paramcalled = {};\n\n  // middleware and routes\n  const stack = this.stack;\n\n  // manage inter-router variables\n  const parentParams = req.params;\n  const parentUrl = req.baseUrl || '';\n  let done = restore(callback, req, 'baseUrl', 'next', 'params');\n\n  // setup next layer\n  req.next = next;\n\n  // for options requests, respond with a default if nothing else responds\n  if (req.method === 'OPTIONS') {\n    methods = [];\n    done = wrap(done, generateOptionsResponder(res, methods));\n  }\n\n  // setup basic req values\n  req.baseUrl = parentUrl;\n  req.originalUrl = req.originalUrl || req.url;\n  next();\n  function next(err) {\n    let layerError = err === 'route' ? null : err;\n\n    // remove added slash\n    if (slashAdded) {\n      req.url = req.url.slice(1);\n      slashAdded = false;\n    }\n\n    // restore altered req.url\n    if (removed.length !== 0) {\n      req.baseUrl = parentUrl;\n      req.url = protohost + removed + req.url.slice(protohost.length);\n      removed = '';\n    }\n\n    // signal to exit router\n    if (layerError === 'router') {\n      setImmediate(done, null);\n      return;\n    }\n\n    // no more matching layers\n    if (idx >= stack.length) {\n      setImmediate(done, layerError);\n      return;\n    }\n\n    // max sync stack\n    if (++sync > 100) {\n      return setImmediate(next, err);\n    }\n\n    // get pathname of request\n    const path = getPathname(req);\n    if (path == null) {\n      return done(layerError);\n    }\n\n    // find next matching layer\n    let layer;\n    let match;\n    let route;\n    while (match !== true && idx < stack.length) {\n      layer = stack[idx++];\n      match = matchLayer(layer, path);\n      route = layer.route;\n      if (typeof match !== 'boolean') {\n        // hold on to layerError\n        layerError = layerError || match;\n      }\n      if (match !== true) {\n        continue;\n      }\n      if (!route) {\n        // process non-route handlers normally\n        continue;\n      }\n      if (layerError) {\n        // routes do not match with a pending error\n        match = false;\n        continue;\n      }\n      const method = req.method;\n      const hasMethod = route._handlesMethod(method);\n\n      // build up automatic options response\n      if (!hasMethod && method === 'OPTIONS' && methods) {\n        methods.push.apply(methods, route._methods());\n      }\n\n      // don't even bother matching route\n      if (!hasMethod && method !== 'HEAD') {\n        match = false;\n      }\n    }\n\n    // no match\n    if (match !== true) {\n      return done(layerError);\n    }\n\n    // store route for dispatch on change\n    if (route) {\n      req.route = route;\n    }\n\n    // Capture one-time layer values\n    req.params = self.mergeParams ? mergeParams(layer.params, parentParams) : layer.params;\n    const layerPath = layer.path;\n\n    // this should be done for the layer\n    processParams(self.params, layer, paramcalled, req, res, function (err) {\n      if (err) {\n        next(layerError || err);\n      } else if (route) {\n        layer.handleRequest(req, res, next);\n      } else {\n        trimPrefix(layer, layerError, layerPath, path);\n      }\n      sync = 0;\n    });\n  }\n  function trimPrefix(layer, layerError, layerPath, path) {\n    if (layerPath.length !== 0) {\n      // Validate path is a prefix match\n      if (layerPath !== path.substring(0, layerPath.length)) {\n        next(layerError);\n        return;\n      }\n\n      // Validate path breaks on a path separator\n      const c = path[layerPath.length];\n      if (c && c !== '/') {\n        next(layerError);\n        return;\n      }\n\n      // Trim off the part of the url that matches the route\n      // middleware (.use stuff) needs to have the path stripped\n      debug('trim prefix (%s) from url %s', layerPath, req.url);\n      removed = layerPath;\n      req.url = protohost + req.url.slice(protohost.length + removed.length);\n\n      // Ensure leading slash\n      if (!protohost && req.url[0] !== '/') {\n        req.url = '/' + req.url;\n        slashAdded = true;\n      }\n\n      // Setup base URL (no trailing slash)\n      req.baseUrl = parentUrl + (removed[removed.length - 1] === '/' ? removed.substring(0, removed.length - 1) : removed);\n    }\n    debug('%s %s : %s', layer.name, layerPath, req.originalUrl);\n    if (layerError) {\n      layer.handleError(layerError, req, res, next);\n    } else {\n      layer.handleRequest(req, res, next);\n    }\n  }\n};\n\n/**\n * Use the given middleware function, with optional path, defaulting to \"/\".\n *\n * Use (like `.all`) will run for any http METHOD, but it will not add\n * handlers for those methods so OPTIONS requests will not consider `.use`\n * functions even if they could respond.\n *\n * The other difference is that _route_ path is stripped and not visible\n * to the handler function. The main effect of this feature is that mounted\n * handlers can operate without any code changes regardless of the \"prefix\"\n * pathname.\n *\n * @public\n */\n\nRouter.prototype.use = function use(handler) {\n  let offset = 0;\n  let path = '/';\n\n  // default path to '/'\n  // disambiguate router.use([handler])\n  if (typeof handler !== 'function') {\n    let arg = handler;\n    while (Array.isArray(arg) && arg.length !== 0) {\n      arg = arg[0];\n    }\n\n    // first arg is the path\n    if (typeof arg !== 'function') {\n      offset = 1;\n      path = handler;\n    }\n  }\n  const callbacks = flatten.call(slice.call(arguments, offset), Infinity);\n  if (callbacks.length === 0) {\n    throw new TypeError('argument handler is required');\n  }\n  for (let i = 0; i < callbacks.length; i++) {\n    const fn = callbacks[i];\n    if (typeof fn !== 'function') {\n      throw new TypeError('argument handler must be a function');\n    }\n\n    // add the middleware\n    debug('use %o %s', path, fn.name || '<anonymous>');\n    const layer = new Layer(path, {\n      sensitive: this.caseSensitive,\n      strict: false,\n      end: false\n    }, fn);\n    layer.route = undefined;\n    this.stack.push(layer);\n  }\n  return this;\n};\n\n/**\n * Create a new Route for the given path.\n *\n * Each route contains a separate middleware stack and VERB handlers.\n *\n * See the Route api documentation for details on adding handlers\n * and middleware to routes.\n *\n * @param {string} path\n * @return {Route}\n * @public\n */\n\nRouter.prototype.route = function route(path) {\n  const route = new Route(path);\n  const layer = new Layer(path, {\n    sensitive: this.caseSensitive,\n    strict: this.strict,\n    end: true\n  }, handle);\n  function handle(req, res, next) {\n    route.dispatch(req, res, next);\n  }\n  layer.route = route;\n  this.stack.push(layer);\n  return route;\n};\n\n// create Router#VERB functions\nmethods.concat('all').forEach(function (method) {\n  Router.prototype[method] = function (path) {\n    const route = this.route(path);\n    route[method].apply(route, slice.call(arguments, 1));\n    return this;\n  };\n});\n\n/**\n * Generate a callback that will make an OPTIONS response.\n *\n * @param {OutgoingMessage} res\n * @param {array} methods\n * @private\n */\n\nfunction generateOptionsResponder(res, methods) {\n  return function onDone(fn, err) {\n    if (err || methods.length === 0) {\n      return fn(err);\n    }\n    trySendOptionsResponse(res, methods, fn);\n  };\n}\n\n/**\n * Get pathname of request.\n *\n * @param {IncomingMessage} req\n * @private\n */\n\nfunction getPathname(req) {\n  try {\n    return parseUrl(req).pathname;\n  } catch (err) {\n    return undefined;\n  }\n}\n\n/**\n * Get get protocol + host for a URL.\n *\n * @param {string} url\n * @private\n */\n\nfunction getProtohost(url) {\n  if (typeof url !== 'string' || url.length === 0 || url[0] === '/') {\n    return undefined;\n  }\n  const searchIndex = url.indexOf('?');\n  const pathLength = searchIndex !== -1 ? searchIndex : url.length;\n  const fqdnIndex = url.substring(0, pathLength).indexOf('://');\n  return fqdnIndex !== -1 ? url.substring(0, url.indexOf('/', 3 + fqdnIndex)) : undefined;\n}\n\n/**\n * Match path to a layer.\n *\n * @param {Layer} layer\n * @param {string} path\n * @private\n */\n\nfunction matchLayer(layer, path) {\n  try {\n    return layer.match(path);\n  } catch (err) {\n    return err;\n  }\n}\n\n/**\n * Merge params with parent params\n *\n * @private\n */\n\nfunction mergeParams(params, parent) {\n  if (typeof parent !== 'object' || !parent) {\n    return params;\n  }\n\n  // make copy of parent for base\n  const obj = Object.assign({}, parent);\n\n  // simple non-numeric merging\n  if (!(0 in params) || !(0 in parent)) {\n    return Object.assign(obj, params);\n  }\n  let i = 0;\n  let o = 0;\n\n  // determine numeric gap in params\n  while (i in params) {\n    i++;\n  }\n\n  // determine numeric gap in parent\n  while (o in parent) {\n    o++;\n  }\n\n  // offset numeric indices in params before merge\n  for (i--; i >= 0; i--) {\n    params[i + o] = params[i];\n\n    // create holes for the merge when necessary\n    if (i < o) {\n      delete params[i];\n    }\n  }\n  return Object.assign(obj, params);\n}\n\n/**\n * Process any parameters for the layer.\n *\n * @private\n */\n\nfunction processParams(params, layer, called, req, res, done) {\n  // captured parameters from the layer, keys and values\n  const keys = layer.keys;\n\n  // fast track\n  if (!keys || keys.length === 0) {\n    return done();\n  }\n  let i = 0;\n  let paramIndex = 0;\n  let key;\n  let paramVal;\n  let paramCallbacks;\n  let paramCalled;\n\n  // process params in order\n  // param callbacks can be async\n  function param(err) {\n    if (err) {\n      return done(err);\n    }\n    if (i >= keys.length) {\n      return done();\n    }\n    paramIndex = 0;\n    key = keys[i++];\n    paramVal = req.params[key];\n    paramCallbacks = params[key];\n    paramCalled = called[key];\n    if (paramVal === undefined || !paramCallbacks) {\n      return param();\n    }\n\n    // param previously called with same value or error occurred\n    if (paramCalled && (paramCalled.match === paramVal || paramCalled.error && paramCalled.error !== 'route')) {\n      // restore value\n      req.params[key] = paramCalled.value;\n\n      // next param\n      return param(paramCalled.error);\n    }\n    called[key] = paramCalled = {\n      error: null,\n      match: paramVal,\n      value: paramVal\n    };\n    paramCallback();\n  }\n\n  // single param callbacks\n  function paramCallback(err) {\n    const fn = paramCallbacks[paramIndex++];\n\n    // store updated value\n    paramCalled.value = req.params[key];\n    if (err) {\n      // store error\n      paramCalled.error = err;\n      param(err);\n      return;\n    }\n    if (!fn) return param();\n    try {\n      const ret = fn(req, res, paramCallback, paramVal, key);\n      if (isPromise(ret)) {\n        if (!(ret instanceof Promise)) {\n          deprecate('parameters that are Promise-like are deprecated, use a native Promise instead');\n        }\n        ret.then(null, function (error) {\n          paramCallback(error || new Error('Rejected promise'));\n        });\n      }\n    } catch (e) {\n      paramCallback(e);\n    }\n  }\n  param();\n}\n\n/**\n * Restore obj props after function\n *\n * @private\n */\n\nfunction restore(fn, obj) {\n  const props = new Array(arguments.length - 2);\n  const vals = new Array(arguments.length - 2);\n  for (let i = 0; i < props.length; i++) {\n    props[i] = arguments[i + 2];\n    vals[i] = obj[props[i]];\n  }\n  return function () {\n    // restore vals\n    for (let i = 0; i < props.length; i++) {\n      obj[props[i]] = vals[i];\n    }\n    return fn.apply(this, arguments);\n  };\n}\n\n/**\n * Send an OPTIONS response.\n *\n * @private\n */\n\nfunction sendOptionsResponse(res, methods) {\n  const options = Object.create(null);\n\n  // build unique method map\n  for (let i = 0; i < methods.length; i++) {\n    options[methods[i]] = true;\n  }\n\n  // construct the allow list\n  const allow = Object.keys(options).sort().join(', ');\n\n  // send response\n  res.setHeader('Allow', allow);\n  res.setHeader('Content-Length', Buffer.byteLength(allow));\n  res.setHeader('Content-Type', 'text/plain');\n  res.setHeader('X-Content-Type-Options', 'nosniff');\n  res.end(allow);\n}\n\n/**\n * Try to send an OPTIONS response.\n *\n * @private\n */\n\nfunction trySendOptionsResponse(res, methods, next) {\n  try {\n    sendOptionsResponse(res, methods);\n  } catch (err) {\n    next(err);\n  }\n}\n\n/**\n * Wrap a function\n *\n * @private\n */\n\nfunction wrap(old, fn) {\n  return function proxy() {\n    const args = new Array(arguments.length + 1);\n    args[0] = old;\n    for (let i = 0, len = arguments.length; i < len; i++) {\n      args[i + 1] = arguments[i];\n    }\n    fn.apply(this, args);\n  };\n}","map":{"version":3,"names":["isPromise","require","Layer","METHODS","parseUrl","Route","debug","deprecate","slice","Array","prototype","flatten","flat","methods","map","method","toLowerCase","module","exports","Router","options","opts","router","req","res","next","handle","Object","setPrototypeOf","caseSensitive","mergeParams","params","strict","stack","param","name","fn","TypeError","push","callback","url","idx","protohost","getProtohost","removed","self","slashAdded","sync","paramcalled","parentParams","parentUrl","baseUrl","done","restore","wrap","generateOptionsResponder","originalUrl","err","layerError","length","setImmediate","path","getPathname","layer","match","route","matchLayer","hasMethod","_handlesMethod","apply","_methods","layerPath","processParams","handleRequest","trimPrefix","substring","c","handleError","use","handler","offset","arg","isArray","callbacks","call","arguments","Infinity","i","sensitive","end","undefined","dispatch","concat","forEach","onDone","trySendOptionsResponse","pathname","searchIndex","indexOf","pathLength","fqdnIndex","parent","obj","assign","o","called","keys","paramIndex","key","paramVal","paramCallbacks","paramCalled","error","value","paramCallback","ret","Promise","then","Error","e","props","vals","sendOptionsResponse","create","allow","sort","join","setHeader","Buffer","byteLength","old","proxy","args","len"],"sources":["/Users/linwanjou/Documents/GitHub/SinoPac_Sign_Language/永豐產學/App/node_modules/router/index.js"],"sourcesContent":["/*!\n * router\n * Copyright(c) 2013 Roman Shtylman\n * Copyright(c) 2014-2022 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module dependencies.\n * @private\n */\n\nconst isPromise = require('is-promise')\nconst Layer = require('./lib/layer')\nconst { METHODS } = require('node:http')\nconst parseUrl = require('parseurl')\nconst Route = require('./lib/route')\nconst debug = require('debug')('router')\nconst deprecate = require('depd')('router')\n\n/**\n * Module variables.\n * @private\n */\n\nconst slice = Array.prototype.slice\nconst flatten = Array.prototype.flat\nconst methods = METHODS.map((method) => method.toLowerCase())\n\n/**\n * Expose `Router`.\n */\n\nmodule.exports = Router\n\n/**\n * Expose `Route`.\n */\n\nmodule.exports.Route = Route\n\n/**\n * Initialize a new `Router` with the given `options`.\n *\n * @param {object} [options]\n * @return {Router} which is a callable function\n * @public\n */\n\nfunction Router (options) {\n  if (!(this instanceof Router)) {\n    return new Router(options)\n  }\n\n  const opts = options || {}\n\n  function router (req, res, next) {\n    router.handle(req, res, next)\n  }\n\n  // inherit from the correct prototype\n  Object.setPrototypeOf(router, this)\n\n  router.caseSensitive = opts.caseSensitive\n  router.mergeParams = opts.mergeParams\n  router.params = {}\n  router.strict = opts.strict\n  router.stack = []\n\n  return router\n}\n\n/**\n * Router prototype inherits from a Function.\n */\n\n/* istanbul ignore next */\nRouter.prototype = function () {}\n\n/**\n * Map the given param placeholder `name`(s) to the given callback.\n *\n * Parameter mapping is used to provide pre-conditions to routes\n * which use normalized placeholders. For example a _:user_id_ parameter\n * could automatically load a user's information from the database without\n * any additional code.\n *\n * The callback uses the same signature as middleware, the only difference\n * being that the value of the placeholder is passed, in this case the _id_\n * of the user. Once the `next()` function is invoked, just like middleware\n * it will continue on to execute the route, or subsequent parameter functions.\n *\n * Just like in middleware, you must either respond to the request or call next\n * to avoid stalling the request.\n *\n *  router.param('user_id', function(req, res, next, id){\n *    User.find(id, function(err, user){\n *      if (err) {\n *        return next(err)\n *      } else if (!user) {\n *        return next(new Error('failed to load user'))\n *      }\n *      req.user = user\n *      next()\n *    })\n *  })\n *\n * @param {string} name\n * @param {function} fn\n * @public\n */\n\nRouter.prototype.param = function param (name, fn) {\n  if (!name) {\n    throw new TypeError('argument name is required')\n  }\n\n  if (typeof name !== 'string') {\n    throw new TypeError('argument name must be a string')\n  }\n\n  if (!fn) {\n    throw new TypeError('argument fn is required')\n  }\n\n  if (typeof fn !== 'function') {\n    throw new TypeError('argument fn must be a function')\n  }\n\n  let params = this.params[name]\n\n  if (!params) {\n    params = this.params[name] = []\n  }\n\n  params.push(fn)\n\n  return this\n}\n\n/**\n * Dispatch a req, res into the router.\n *\n * @private\n */\n\nRouter.prototype.handle = function handle (req, res, callback) {\n  if (!callback) {\n    throw new TypeError('argument callback is required')\n  }\n\n  debug('dispatching %s %s', req.method, req.url)\n\n  let idx = 0\n  let methods\n  const protohost = getProtohost(req.url) || ''\n  let removed = ''\n  const self = this\n  let slashAdded = false\n  let sync = 0\n  const paramcalled = {}\n\n  // middleware and routes\n  const stack = this.stack\n\n  // manage inter-router variables\n  const parentParams = req.params\n  const parentUrl = req.baseUrl || ''\n  let done = restore(callback, req, 'baseUrl', 'next', 'params')\n\n  // setup next layer\n  req.next = next\n\n  // for options requests, respond with a default if nothing else responds\n  if (req.method === 'OPTIONS') {\n    methods = []\n    done = wrap(done, generateOptionsResponder(res, methods))\n  }\n\n  // setup basic req values\n  req.baseUrl = parentUrl\n  req.originalUrl = req.originalUrl || req.url\n\n  next()\n\n  function next (err) {\n    let layerError = err === 'route'\n      ? null\n      : err\n\n    // remove added slash\n    if (slashAdded) {\n      req.url = req.url.slice(1)\n      slashAdded = false\n    }\n\n    // restore altered req.url\n    if (removed.length !== 0) {\n      req.baseUrl = parentUrl\n      req.url = protohost + removed + req.url.slice(protohost.length)\n      removed = ''\n    }\n\n    // signal to exit router\n    if (layerError === 'router') {\n      setImmediate(done, null)\n      return\n    }\n\n    // no more matching layers\n    if (idx >= stack.length) {\n      setImmediate(done, layerError)\n      return\n    }\n\n    // max sync stack\n    if (++sync > 100) {\n      return setImmediate(next, err)\n    }\n\n    // get pathname of request\n    const path = getPathname(req)\n\n    if (path == null) {\n      return done(layerError)\n    }\n\n    // find next matching layer\n    let layer\n    let match\n    let route\n\n    while (match !== true && idx < stack.length) {\n      layer = stack[idx++]\n      match = matchLayer(layer, path)\n      route = layer.route\n\n      if (typeof match !== 'boolean') {\n        // hold on to layerError\n        layerError = layerError || match\n      }\n\n      if (match !== true) {\n        continue\n      }\n\n      if (!route) {\n        // process non-route handlers normally\n        continue\n      }\n\n      if (layerError) {\n        // routes do not match with a pending error\n        match = false\n        continue\n      }\n\n      const method = req.method\n      const hasMethod = route._handlesMethod(method)\n\n      // build up automatic options response\n      if (!hasMethod && method === 'OPTIONS' && methods) {\n        methods.push.apply(methods, route._methods())\n      }\n\n      // don't even bother matching route\n      if (!hasMethod && method !== 'HEAD') {\n        match = false\n      }\n    }\n\n    // no match\n    if (match !== true) {\n      return done(layerError)\n    }\n\n    // store route for dispatch on change\n    if (route) {\n      req.route = route\n    }\n\n    // Capture one-time layer values\n    req.params = self.mergeParams\n      ? mergeParams(layer.params, parentParams)\n      : layer.params\n    const layerPath = layer.path\n\n    // this should be done for the layer\n    processParams(self.params, layer, paramcalled, req, res, function (err) {\n      if (err) {\n        next(layerError || err)\n      } else if (route) {\n        layer.handleRequest(req, res, next)\n      } else {\n        trimPrefix(layer, layerError, layerPath, path)\n      }\n\n      sync = 0\n    })\n  }\n\n  function trimPrefix (layer, layerError, layerPath, path) {\n    if (layerPath.length !== 0) {\n      // Validate path is a prefix match\n      if (layerPath !== path.substring(0, layerPath.length)) {\n        next(layerError)\n        return\n      }\n\n      // Validate path breaks on a path separator\n      const c = path[layerPath.length]\n      if (c && c !== '/') {\n        next(layerError)\n        return\n      }\n\n      // Trim off the part of the url that matches the route\n      // middleware (.use stuff) needs to have the path stripped\n      debug('trim prefix (%s) from url %s', layerPath, req.url)\n      removed = layerPath\n      req.url = protohost + req.url.slice(protohost.length + removed.length)\n\n      // Ensure leading slash\n      if (!protohost && req.url[0] !== '/') {\n        req.url = '/' + req.url\n        slashAdded = true\n      }\n\n      // Setup base URL (no trailing slash)\n      req.baseUrl = parentUrl + (removed[removed.length - 1] === '/'\n        ? removed.substring(0, removed.length - 1)\n        : removed)\n    }\n\n    debug('%s %s : %s', layer.name, layerPath, req.originalUrl)\n\n    if (layerError) {\n      layer.handleError(layerError, req, res, next)\n    } else {\n      layer.handleRequest(req, res, next)\n    }\n  }\n}\n\n/**\n * Use the given middleware function, with optional path, defaulting to \"/\".\n *\n * Use (like `.all`) will run for any http METHOD, but it will not add\n * handlers for those methods so OPTIONS requests will not consider `.use`\n * functions even if they could respond.\n *\n * The other difference is that _route_ path is stripped and not visible\n * to the handler function. The main effect of this feature is that mounted\n * handlers can operate without any code changes regardless of the \"prefix\"\n * pathname.\n *\n * @public\n */\n\nRouter.prototype.use = function use (handler) {\n  let offset = 0\n  let path = '/'\n\n  // default path to '/'\n  // disambiguate router.use([handler])\n  if (typeof handler !== 'function') {\n    let arg = handler\n\n    while (Array.isArray(arg) && arg.length !== 0) {\n      arg = arg[0]\n    }\n\n    // first arg is the path\n    if (typeof arg !== 'function') {\n      offset = 1\n      path = handler\n    }\n  }\n\n  const callbacks = flatten.call(slice.call(arguments, offset), Infinity)\n\n  if (callbacks.length === 0) {\n    throw new TypeError('argument handler is required')\n  }\n\n  for (let i = 0; i < callbacks.length; i++) {\n    const fn = callbacks[i]\n\n    if (typeof fn !== 'function') {\n      throw new TypeError('argument handler must be a function')\n    }\n\n    // add the middleware\n    debug('use %o %s', path, fn.name || '<anonymous>')\n\n    const layer = new Layer(path, {\n      sensitive: this.caseSensitive,\n      strict: false,\n      end: false\n    }, fn)\n\n    layer.route = undefined\n\n    this.stack.push(layer)\n  }\n\n  return this\n}\n\n/**\n * Create a new Route for the given path.\n *\n * Each route contains a separate middleware stack and VERB handlers.\n *\n * See the Route api documentation for details on adding handlers\n * and middleware to routes.\n *\n * @param {string} path\n * @return {Route}\n * @public\n */\n\nRouter.prototype.route = function route (path) {\n  const route = new Route(path)\n\n  const layer = new Layer(path, {\n    sensitive: this.caseSensitive,\n    strict: this.strict,\n    end: true\n  }, handle)\n\n  function handle (req, res, next) {\n    route.dispatch(req, res, next)\n  }\n\n  layer.route = route\n\n  this.stack.push(layer)\n  return route\n}\n\n// create Router#VERB functions\nmethods.concat('all').forEach(function (method) {\n  Router.prototype[method] = function (path) {\n    const route = this.route(path)\n    route[method].apply(route, slice.call(arguments, 1))\n    return this\n  }\n})\n\n/**\n * Generate a callback that will make an OPTIONS response.\n *\n * @param {OutgoingMessage} res\n * @param {array} methods\n * @private\n */\n\nfunction generateOptionsResponder (res, methods) {\n  return function onDone (fn, err) {\n    if (err || methods.length === 0) {\n      return fn(err)\n    }\n\n    trySendOptionsResponse(res, methods, fn)\n  }\n}\n\n/**\n * Get pathname of request.\n *\n * @param {IncomingMessage} req\n * @private\n */\n\nfunction getPathname (req) {\n  try {\n    return parseUrl(req).pathname\n  } catch (err) {\n    return undefined\n  }\n}\n\n/**\n * Get get protocol + host for a URL.\n *\n * @param {string} url\n * @private\n */\n\nfunction getProtohost (url) {\n  if (typeof url !== 'string' || url.length === 0 || url[0] === '/') {\n    return undefined\n  }\n\n  const searchIndex = url.indexOf('?')\n  const pathLength = searchIndex !== -1\n    ? searchIndex\n    : url.length\n  const fqdnIndex = url.substring(0, pathLength).indexOf('://')\n\n  return fqdnIndex !== -1\n    ? url.substring(0, url.indexOf('/', 3 + fqdnIndex))\n    : undefined\n}\n\n/**\n * Match path to a layer.\n *\n * @param {Layer} layer\n * @param {string} path\n * @private\n */\n\nfunction matchLayer (layer, path) {\n  try {\n    return layer.match(path)\n  } catch (err) {\n    return err\n  }\n}\n\n/**\n * Merge params with parent params\n *\n * @private\n */\n\nfunction mergeParams (params, parent) {\n  if (typeof parent !== 'object' || !parent) {\n    return params\n  }\n\n  // make copy of parent for base\n  const obj = Object.assign({}, parent)\n\n  // simple non-numeric merging\n  if (!(0 in params) || !(0 in parent)) {\n    return Object.assign(obj, params)\n  }\n\n  let i = 0\n  let o = 0\n\n  // determine numeric gap in params\n  while (i in params) {\n    i++\n  }\n\n  // determine numeric gap in parent\n  while (o in parent) {\n    o++\n  }\n\n  // offset numeric indices in params before merge\n  for (i--; i >= 0; i--) {\n    params[i + o] = params[i]\n\n    // create holes for the merge when necessary\n    if (i < o) {\n      delete params[i]\n    }\n  }\n\n  return Object.assign(obj, params)\n}\n\n/**\n * Process any parameters for the layer.\n *\n * @private\n */\n\nfunction processParams (params, layer, called, req, res, done) {\n  // captured parameters from the layer, keys and values\n  const keys = layer.keys\n\n  // fast track\n  if (!keys || keys.length === 0) {\n    return done()\n  }\n\n  let i = 0\n  let paramIndex = 0\n  let key\n  let paramVal\n  let paramCallbacks\n  let paramCalled\n\n  // process params in order\n  // param callbacks can be async\n  function param (err) {\n    if (err) {\n      return done(err)\n    }\n\n    if (i >= keys.length) {\n      return done()\n    }\n\n    paramIndex = 0\n    key = keys[i++]\n    paramVal = req.params[key]\n    paramCallbacks = params[key]\n    paramCalled = called[key]\n\n    if (paramVal === undefined || !paramCallbacks) {\n      return param()\n    }\n\n    // param previously called with same value or error occurred\n    if (paramCalled && (paramCalled.match === paramVal ||\n      (paramCalled.error && paramCalled.error !== 'route'))) {\n      // restore value\n      req.params[key] = paramCalled.value\n\n      // next param\n      return param(paramCalled.error)\n    }\n\n    called[key] = paramCalled = {\n      error: null,\n      match: paramVal,\n      value: paramVal\n    }\n\n    paramCallback()\n  }\n\n  // single param callbacks\n  function paramCallback (err) {\n    const fn = paramCallbacks[paramIndex++]\n\n    // store updated value\n    paramCalled.value = req.params[key]\n\n    if (err) {\n      // store error\n      paramCalled.error = err\n      param(err)\n      return\n    }\n\n    if (!fn) return param()\n\n    try {\n      const ret = fn(req, res, paramCallback, paramVal, key)\n      if (isPromise(ret)) {\n        if (!(ret instanceof Promise)) {\n          deprecate('parameters that are Promise-like are deprecated, use a native Promise instead')\n        }\n\n        ret.then(null, function (error) {\n          paramCallback(error || new Error('Rejected promise'))\n        })\n      }\n    } catch (e) {\n      paramCallback(e)\n    }\n  }\n\n  param()\n}\n\n/**\n * Restore obj props after function\n *\n * @private\n */\n\nfunction restore (fn, obj) {\n  const props = new Array(arguments.length - 2)\n  const vals = new Array(arguments.length - 2)\n\n  for (let i = 0; i < props.length; i++) {\n    props[i] = arguments[i + 2]\n    vals[i] = obj[props[i]]\n  }\n\n  return function () {\n    // restore vals\n    for (let i = 0; i < props.length; i++) {\n      obj[props[i]] = vals[i]\n    }\n\n    return fn.apply(this, arguments)\n  }\n}\n\n/**\n * Send an OPTIONS response.\n *\n * @private\n */\n\nfunction sendOptionsResponse (res, methods) {\n  const options = Object.create(null)\n\n  // build unique method map\n  for (let i = 0; i < methods.length; i++) {\n    options[methods[i]] = true\n  }\n\n  // construct the allow list\n  const allow = Object.keys(options).sort().join(', ')\n\n  // send response\n  res.setHeader('Allow', allow)\n  res.setHeader('Content-Length', Buffer.byteLength(allow))\n  res.setHeader('Content-Type', 'text/plain')\n  res.setHeader('X-Content-Type-Options', 'nosniff')\n  res.end(allow)\n}\n\n/**\n * Try to send an OPTIONS response.\n *\n * @private\n */\n\nfunction trySendOptionsResponse (res, methods, next) {\n  try {\n    sendOptionsResponse(res, methods)\n  } catch (err) {\n    next(err)\n  }\n}\n\n/**\n * Wrap a function\n *\n * @private\n */\n\nfunction wrap (old, fn) {\n  return function proxy () {\n    const args = new Array(arguments.length + 1)\n\n    args[0] = old\n    for (let i = 0, len = arguments.length; i < len; i++) {\n      args[i + 1] = arguments[i]\n    }\n\n    fn.apply(this, args)\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}