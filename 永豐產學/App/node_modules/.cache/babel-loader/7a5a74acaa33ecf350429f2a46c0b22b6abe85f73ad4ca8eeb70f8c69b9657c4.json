{"ast":null,"code":"/*!\n * router\n * Copyright(c) 2013 Roman Shtylman\n * Copyright(c) 2014-2022 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Module dependencies.\n * @private\n */\nconst isPromise = require('is-promise');\nconst pathRegexp = require('path-to-regexp');\nconst debug = require('debug')('router:layer');\nconst deprecate = require('depd')('router');\n\n/**\n * Module variables.\n * @private\n */\n\nconst TRAILING_SLASH_REGEXP = /\\/+$/;\nconst MATCHING_GROUP_REGEXP = /\\((?:\\?<(.*?)>)?(?!\\?)/g;\n\n/**\n * Expose `Layer`.\n */\n\nmodule.exports = Layer;\nfunction Layer(path, options, fn) {\n  if (!(this instanceof Layer)) {\n    return new Layer(path, options, fn);\n  }\n  debug('new %o', path);\n  const opts = options || {};\n  this.handle = fn;\n  this.keys = [];\n  this.name = fn.name || '<anonymous>';\n  this.params = undefined;\n  this.path = undefined;\n  this.slash = path === '/' && opts.end === false;\n  function matcher(_path) {\n    if (_path instanceof RegExp) {\n      const keys = [];\n      let name = 0;\n      let m;\n      // eslint-disable-next-line no-cond-assign\n      while (m = MATCHING_GROUP_REGEXP.exec(_path.source)) {\n        keys.push({\n          name: m[1] || name++,\n          offset: m.index\n        });\n      }\n      return function regexpMatcher(p) {\n        const match = _path.exec(p);\n        if (!match) {\n          return false;\n        }\n        const params = {};\n        for (let i = 1; i < match.length; i++) {\n          const key = keys[i - 1];\n          const prop = key.name;\n          const val = decodeParam(match[i]);\n          if (val !== undefined) {\n            params[prop] = val;\n          }\n        }\n        return {\n          params,\n          path: match[0]\n        };\n      };\n    }\n    return pathRegexp.match(opts.strict ? _path : loosen(_path), {\n      sensitive: opts.sensitive,\n      end: opts.end,\n      trailing: !opts.strict,\n      decode: decodeParam\n    });\n  }\n  this.matchers = Array.isArray(path) ? path.map(matcher) : [matcher(path)];\n}\n\n/**\n * Handle the error for the layer.\n *\n * @param {Error} error\n * @param {Request} req\n * @param {Response} res\n * @param {function} next\n * @api private\n */\n\nLayer.prototype.handleError = function handleError(error, req, res, next) {\n  const fn = this.handle;\n  if (fn.length !== 4) {\n    // not a standard error handler\n    return next(error);\n  }\n  try {\n    // invoke function\n    const ret = fn(error, req, res, next);\n\n    // wait for returned promise\n    if (isPromise(ret)) {\n      if (!(ret instanceof Promise)) {\n        deprecate('handlers that are Promise-like are deprecated, use a native Promise instead');\n      }\n      ret.then(null, function (error) {\n        next(error || new Error('Rejected promise'));\n      });\n    }\n  } catch (err) {\n    next(err);\n  }\n};\n\n/**\n * Handle the request for the layer.\n *\n * @param {Request} req\n * @param {Response} res\n * @param {function} next\n * @api private\n */\n\nLayer.prototype.handleRequest = function handleRequest(req, res, next) {\n  const fn = this.handle;\n  if (fn.length > 3) {\n    // not a standard request handler\n    return next();\n  }\n  try {\n    // invoke function\n    const ret = fn(req, res, next);\n\n    // wait for returned promise\n    if (isPromise(ret)) {\n      if (!(ret instanceof Promise)) {\n        deprecate('handlers that are Promise-like are deprecated, use a native Promise instead');\n      }\n      ret.then(null, function (error) {\n        next(error || new Error('Rejected promise'));\n      });\n    }\n  } catch (err) {\n    next(err);\n  }\n};\n\n/**\n * Check if this route matches `path`, if so\n * populate `.params`.\n *\n * @param {String} path\n * @return {Boolean}\n * @api private\n */\n\nLayer.prototype.match = function match(path) {\n  let match;\n  if (path != null) {\n    // fast path non-ending match for / (any path matches)\n    if (this.slash) {\n      this.params = {};\n      this.path = '';\n      return true;\n    }\n    let i = 0;\n    while (!match && i < this.matchers.length) {\n      // match the path\n      match = this.matchers[i](path);\n      i++;\n    }\n  }\n  if (!match) {\n    this.params = undefined;\n    this.path = undefined;\n    return false;\n  }\n\n  // store values\n  this.params = match.params;\n  this.path = match.path;\n  this.keys = Object.keys(match.params);\n  return true;\n};\n\n/**\n * Decode param value.\n *\n * @param {string} val\n * @return {string}\n * @private\n */\n\nfunction decodeParam(val) {\n  if (typeof val !== 'string' || val.length === 0) {\n    return val;\n  }\n  try {\n    return decodeURIComponent(val);\n  } catch (err) {\n    if (err instanceof URIError) {\n      err.message = 'Failed to decode param \\'' + val + '\\'';\n      err.status = 400;\n    }\n    throw err;\n  }\n}\n\n/**\n * Loosens the given path for path-to-regexp matching.\n */\nfunction loosen(path) {\n  if (path instanceof RegExp || path === '/') {\n    return path;\n  }\n  return Array.isArray(path) ? path.map(function (p) {\n    return loosen(p);\n  }) : String(path).replace(TRAILING_SLASH_REGEXP, '');\n}","map":{"version":3,"names":["isPromise","require","pathRegexp","debug","deprecate","TRAILING_SLASH_REGEXP","MATCHING_GROUP_REGEXP","module","exports","Layer","path","options","fn","opts","handle","keys","name","params","undefined","slash","end","matcher","_path","RegExp","m","exec","source","push","offset","index","regexpMatcher","p","match","i","length","key","prop","val","decodeParam","strict","loosen","sensitive","trailing","decode","matchers","Array","isArray","map","prototype","handleError","error","req","res","next","ret","Promise","then","Error","err","handleRequest","Object","decodeURIComponent","URIError","message","status","String","replace"],"sources":["/Users/linwanjou/Documents/GitHub/SinoPac_Sign_Language/永豐產學/App/node_modules/router/lib/layer.js"],"sourcesContent":["/*!\n * router\n * Copyright(c) 2013 Roman Shtylman\n * Copyright(c) 2014-2022 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module dependencies.\n * @private\n */\n\nconst isPromise = require('is-promise')\nconst pathRegexp = require('path-to-regexp')\nconst debug = require('debug')('router:layer')\nconst deprecate = require('depd')('router')\n\n/**\n * Module variables.\n * @private\n */\n\nconst TRAILING_SLASH_REGEXP = /\\/+$/\nconst MATCHING_GROUP_REGEXP = /\\((?:\\?<(.*?)>)?(?!\\?)/g\n\n/**\n * Expose `Layer`.\n */\n\nmodule.exports = Layer\n\nfunction Layer (path, options, fn) {\n  if (!(this instanceof Layer)) {\n    return new Layer(path, options, fn)\n  }\n\n  debug('new %o', path)\n  const opts = options || {}\n\n  this.handle = fn\n  this.keys = []\n  this.name = fn.name || '<anonymous>'\n  this.params = undefined\n  this.path = undefined\n  this.slash = path === '/' && opts.end === false\n\n  function matcher (_path) {\n    if (_path instanceof RegExp) {\n      const keys = []\n      let name = 0\n      let m\n      // eslint-disable-next-line no-cond-assign\n      while (m = MATCHING_GROUP_REGEXP.exec(_path.source)) {\n        keys.push({\n          name: m[1] || name++,\n          offset: m.index\n        })\n      }\n\n      return function regexpMatcher (p) {\n        const match = _path.exec(p)\n        if (!match) {\n          return false\n        }\n\n        const params = {}\n        for (let i = 1; i < match.length; i++) {\n          const key = keys[i - 1]\n          const prop = key.name\n          const val = decodeParam(match[i])\n\n          if (val !== undefined) {\n            params[prop] = val\n          }\n        }\n\n        return {\n          params,\n          path: match[0]\n        }\n      }\n    }\n\n    return pathRegexp.match((opts.strict ? _path : loosen(_path)), {\n      sensitive: opts.sensitive,\n      end: opts.end,\n      trailing: !opts.strict,\n      decode: decodeParam\n    })\n  }\n  this.matchers = Array.isArray(path) ? path.map(matcher) : [matcher(path)]\n}\n\n/**\n * Handle the error for the layer.\n *\n * @param {Error} error\n * @param {Request} req\n * @param {Response} res\n * @param {function} next\n * @api private\n */\n\nLayer.prototype.handleError = function handleError (error, req, res, next) {\n  const fn = this.handle\n\n  if (fn.length !== 4) {\n    // not a standard error handler\n    return next(error)\n  }\n\n  try {\n    // invoke function\n    const ret = fn(error, req, res, next)\n\n    // wait for returned promise\n    if (isPromise(ret)) {\n      if (!(ret instanceof Promise)) {\n        deprecate('handlers that are Promise-like are deprecated, use a native Promise instead')\n      }\n\n      ret.then(null, function (error) {\n        next(error || new Error('Rejected promise'))\n      })\n    }\n  } catch (err) {\n    next(err)\n  }\n}\n\n/**\n * Handle the request for the layer.\n *\n * @param {Request} req\n * @param {Response} res\n * @param {function} next\n * @api private\n */\n\nLayer.prototype.handleRequest = function handleRequest (req, res, next) {\n  const fn = this.handle\n\n  if (fn.length > 3) {\n    // not a standard request handler\n    return next()\n  }\n\n  try {\n    // invoke function\n    const ret = fn(req, res, next)\n\n    // wait for returned promise\n    if (isPromise(ret)) {\n      if (!(ret instanceof Promise)) {\n        deprecate('handlers that are Promise-like are deprecated, use a native Promise instead')\n      }\n\n      ret.then(null, function (error) {\n        next(error || new Error('Rejected promise'))\n      })\n    }\n  } catch (err) {\n    next(err)\n  }\n}\n\n/**\n * Check if this route matches `path`, if so\n * populate `.params`.\n *\n * @param {String} path\n * @return {Boolean}\n * @api private\n */\n\nLayer.prototype.match = function match (path) {\n  let match\n\n  if (path != null) {\n    // fast path non-ending match for / (any path matches)\n    if (this.slash) {\n      this.params = {}\n      this.path = ''\n      return true\n    }\n\n    let i = 0\n    while (!match && i < this.matchers.length) {\n      // match the path\n      match = this.matchers[i](path)\n      i++\n    }\n  }\n\n  if (!match) {\n    this.params = undefined\n    this.path = undefined\n    return false\n  }\n\n  // store values\n  this.params = match.params\n  this.path = match.path\n  this.keys = Object.keys(match.params)\n\n  return true\n}\n\n/**\n * Decode param value.\n *\n * @param {string} val\n * @return {string}\n * @private\n */\n\nfunction decodeParam (val) {\n  if (typeof val !== 'string' || val.length === 0) {\n    return val\n  }\n\n  try {\n    return decodeURIComponent(val)\n  } catch (err) {\n    if (err instanceof URIError) {\n      err.message = 'Failed to decode param \\'' + val + '\\''\n      err.status = 400\n    }\n\n    throw err\n  }\n}\n\n/**\n * Loosens the given path for path-to-regexp matching.\n */\nfunction loosen (path) {\n  if (path instanceof RegExp || path === '/') {\n    return path\n  }\n\n  return Array.isArray(path)\n    ? path.map(function (p) { return loosen(p) })\n    : String(path).replace(TRAILING_SLASH_REGEXP, '')\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}