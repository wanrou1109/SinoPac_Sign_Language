{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TokenData = void 0;\nexports.parse = parse;\nexports.compile = compile;\nexports.match = match;\nexports.pathToRegexp = pathToRegexp;\nexports.stringify = stringify;\nconst DEFAULT_DELIMITER = \"/\";\nconst NOOP_VALUE = value => value;\nconst ID_START = /^[$_\\p{ID_Start}]$/u;\nconst ID_CONTINUE = /^[$\\u200c\\u200d\\p{ID_Continue}]$/u;\nconst DEBUG_URL = \"https://git.new/pathToRegexpError\";\nconst SIMPLE_TOKENS = {\n  // Groups.\n  \"{\": \"{\",\n  \"}\": \"}\",\n  // Reserved.\n  \"(\": \"(\",\n  \")\": \")\",\n  \"[\": \"[\",\n  \"]\": \"]\",\n  \"+\": \"+\",\n  \"?\": \"?\",\n  \"!\": \"!\"\n};\n/**\n * Escape text for stringify to path.\n */\nfunction escapeText(str) {\n  return str.replace(/[{}()\\[\\]+?!:*]/g, \"\\\\$&\");\n}\n/**\n * Escape a regular expression string.\n */\nfunction escape(str) {\n  return str.replace(/[.+*?^${}()[\\]|/\\\\]/g, \"\\\\$&\");\n}\n/**\n * Tokenize input string.\n */\nfunction* lexer(str) {\n  const chars = [...str];\n  let i = 0;\n  function name() {\n    let value = \"\";\n    if (ID_START.test(chars[++i])) {\n      value += chars[i];\n      while (ID_CONTINUE.test(chars[++i])) {\n        value += chars[i];\n      }\n    } else if (chars[i] === '\"') {\n      let pos = i;\n      while (i < chars.length) {\n        if (chars[++i] === '\"') {\n          i++;\n          pos = 0;\n          break;\n        }\n        if (chars[i] === \"\\\\\") {\n          value += chars[++i];\n        } else {\n          value += chars[i];\n        }\n      }\n      if (pos) {\n        throw new TypeError(`Unterminated quote at ${pos}: ${DEBUG_URL}`);\n      }\n    }\n    if (!value) {\n      throw new TypeError(`Missing parameter name at ${i}: ${DEBUG_URL}`);\n    }\n    return value;\n  }\n  while (i < chars.length) {\n    const value = chars[i];\n    const type = SIMPLE_TOKENS[value];\n    if (type) {\n      yield {\n        type,\n        index: i++,\n        value\n      };\n    } else if (value === \"\\\\\") {\n      yield {\n        type: \"ESCAPED\",\n        index: i++,\n        value: chars[i++]\n      };\n    } else if (value === \":\") {\n      const value = name();\n      yield {\n        type: \"PARAM\",\n        index: i,\n        value\n      };\n    } else if (value === \"*\") {\n      const value = name();\n      yield {\n        type: \"WILDCARD\",\n        index: i,\n        value\n      };\n    } else {\n      yield {\n        type: \"CHAR\",\n        index: i,\n        value: chars[i++]\n      };\n    }\n  }\n  return {\n    type: \"END\",\n    index: i,\n    value: \"\"\n  };\n}\nclass Iter {\n  constructor(tokens) {\n    this.tokens = tokens;\n  }\n  peek() {\n    if (!this._peek) {\n      const next = this.tokens.next();\n      this._peek = next.value;\n    }\n    return this._peek;\n  }\n  tryConsume(type) {\n    const token = this.peek();\n    if (token.type !== type) return;\n    this._peek = undefined; // Reset after consumed.\n    return token.value;\n  }\n  consume(type) {\n    const value = this.tryConsume(type);\n    if (value !== undefined) return value;\n    const {\n      type: nextType,\n      index\n    } = this.peek();\n    throw new TypeError(`Unexpected ${nextType} at ${index}, expected ${type}: ${DEBUG_URL}`);\n  }\n  text() {\n    let result = \"\";\n    let value;\n    while (value = this.tryConsume(\"CHAR\") || this.tryConsume(\"ESCAPED\")) {\n      result += value;\n    }\n    return result;\n  }\n}\n/**\n * Tokenized path instance.\n */\nclass TokenData {\n  constructor(tokens) {\n    this.tokens = tokens;\n  }\n}\nexports.TokenData = TokenData;\n/**\n * Parse a string for the raw tokens.\n */\nfunction parse(str, options = {}) {\n  const {\n    encodePath = NOOP_VALUE\n  } = options;\n  const it = new Iter(lexer(str));\n  function consume(endType) {\n    const tokens = [];\n    while (true) {\n      const path = it.text();\n      if (path) tokens.push({\n        type: \"text\",\n        value: encodePath(path)\n      });\n      const param = it.tryConsume(\"PARAM\");\n      if (param) {\n        tokens.push({\n          type: \"param\",\n          name: param\n        });\n        continue;\n      }\n      const wildcard = it.tryConsume(\"WILDCARD\");\n      if (wildcard) {\n        tokens.push({\n          type: \"wildcard\",\n          name: wildcard\n        });\n        continue;\n      }\n      const open = it.tryConsume(\"{\");\n      if (open) {\n        tokens.push({\n          type: \"group\",\n          tokens: consume(\"}\")\n        });\n        continue;\n      }\n      it.consume(endType);\n      return tokens;\n    }\n  }\n  const tokens = consume(\"END\");\n  return new TokenData(tokens);\n}\n/**\n * Compile a string to a template function for the path.\n */\nfunction compile(path, options = {}) {\n  const {\n    encode = encodeURIComponent,\n    delimiter = DEFAULT_DELIMITER\n  } = options;\n  const data = path instanceof TokenData ? path : parse(path, options);\n  const fn = tokensToFunction(data.tokens, delimiter, encode);\n  return function path(data = {}) {\n    const [path, ...missing] = fn(data);\n    if (missing.length) {\n      throw new TypeError(`Missing parameters: ${missing.join(\", \")}`);\n    }\n    return path;\n  };\n}\nfunction tokensToFunction(tokens, delimiter, encode) {\n  const encoders = tokens.map(token => tokenToFunction(token, delimiter, encode));\n  return data => {\n    const result = [\"\"];\n    for (const encoder of encoders) {\n      const [value, ...extras] = encoder(data);\n      result[0] += value;\n      result.push(...extras);\n    }\n    return result;\n  };\n}\n/**\n * Convert a single token into a path building function.\n */\nfunction tokenToFunction(token, delimiter, encode) {\n  if (token.type === \"text\") return () => [token.value];\n  if (token.type === \"group\") {\n    const fn = tokensToFunction(token.tokens, delimiter, encode);\n    return data => {\n      const [value, ...missing] = fn(data);\n      if (!missing.length) return [value];\n      return [\"\"];\n    };\n  }\n  const encodeValue = encode || NOOP_VALUE;\n  if (token.type === \"wildcard\" && encode !== false) {\n    return data => {\n      const value = data[token.name];\n      if (value == null) return [\"\", token.name];\n      if (!Array.isArray(value) || value.length === 0) {\n        throw new TypeError(`Expected \"${token.name}\" to be a non-empty array`);\n      }\n      return [value.map((value, index) => {\n        if (typeof value !== \"string\") {\n          throw new TypeError(`Expected \"${token.name}/${index}\" to be a string`);\n        }\n        return encodeValue(value);\n      }).join(delimiter)];\n    };\n  }\n  return data => {\n    const value = data[token.name];\n    if (value == null) return [\"\", token.name];\n    if (typeof value !== \"string\") {\n      throw new TypeError(`Expected \"${token.name}\" to be a string`);\n    }\n    return [encodeValue(value)];\n  };\n}\n/**\n * Transform a path into a match function.\n */\nfunction match(path, options = {}) {\n  const {\n    decode = decodeURIComponent,\n    delimiter = DEFAULT_DELIMITER\n  } = options;\n  const {\n    regexp,\n    keys\n  } = pathToRegexp(path, options);\n  const decoders = keys.map(key => {\n    if (decode === false) return NOOP_VALUE;\n    if (key.type === \"param\") return decode;\n    return value => value.split(delimiter).map(decode);\n  });\n  return function match(input) {\n    const m = regexp.exec(input);\n    if (!m) return false;\n    const path = m[0];\n    const params = Object.create(null);\n    for (let i = 1; i < m.length; i++) {\n      if (m[i] === undefined) continue;\n      const key = keys[i - 1];\n      const decoder = decoders[i - 1];\n      params[key.name] = decoder(m[i]);\n    }\n    return {\n      path,\n      params\n    };\n  };\n}\nfunction pathToRegexp(path, options = {}) {\n  const {\n    delimiter = DEFAULT_DELIMITER,\n    end = true,\n    sensitive = false,\n    trailing = true\n  } = options;\n  const keys = [];\n  const sources = [];\n  const flags = sensitive ? \"\" : \"i\";\n  const paths = Array.isArray(path) ? path : [path];\n  const items = paths.map(path => path instanceof TokenData ? path : parse(path, options));\n  for (const {\n    tokens\n  } of items) {\n    for (const seq of flatten(tokens, 0, [])) {\n      const regexp = sequenceToRegExp(seq, delimiter, keys);\n      sources.push(regexp);\n    }\n  }\n  let pattern = `^(?:${sources.join(\"|\")})`;\n  if (trailing) pattern += `(?:${escape(delimiter)}$)?`;\n  pattern += end ? \"$\" : `(?=${escape(delimiter)}|$)`;\n  const regexp = new RegExp(pattern, flags);\n  return {\n    regexp,\n    keys\n  };\n}\n/**\n * Generate a flat list of sequence tokens from the given tokens.\n */\nfunction* flatten(tokens, index, init) {\n  if (index === tokens.length) {\n    return yield init;\n  }\n  const token = tokens[index];\n  if (token.type === \"group\") {\n    const fork = init.slice();\n    for (const seq of flatten(token.tokens, 0, fork)) {\n      yield* flatten(tokens, index + 1, seq);\n    }\n  } else {\n    init.push(token);\n  }\n  yield* flatten(tokens, index + 1, init);\n}\n/**\n * Transform a flat sequence of tokens into a regular expression.\n */\nfunction sequenceToRegExp(tokens, delimiter, keys) {\n  let result = \"\";\n  let backtrack = \"\";\n  let isSafeSegmentParam = true;\n  for (let i = 0; i < tokens.length; i++) {\n    const token = tokens[i];\n    if (token.type === \"text\") {\n      result += escape(token.value);\n      backtrack += token.value;\n      isSafeSegmentParam || (isSafeSegmentParam = token.value.includes(delimiter));\n      continue;\n    }\n    if (token.type === \"param\" || token.type === \"wildcard\") {\n      if (!isSafeSegmentParam && !backtrack) {\n        throw new TypeError(`Missing text after \"${token.name}\": ${DEBUG_URL}`);\n      }\n      if (token.type === \"param\") {\n        result += `(${negate(delimiter, isSafeSegmentParam ? \"\" : backtrack)}+)`;\n      } else {\n        result += `([\\\\s\\\\S]+)`;\n      }\n      keys.push(token);\n      backtrack = \"\";\n      isSafeSegmentParam = false;\n      continue;\n    }\n  }\n  return result;\n}\nfunction negate(delimiter, backtrack) {\n  if (backtrack.length < 2) {\n    if (delimiter.length < 2) return `[^${escape(delimiter + backtrack)}]`;\n    return `(?:(?!${escape(delimiter)})[^${escape(backtrack)}])`;\n  }\n  if (delimiter.length < 2) {\n    return `(?:(?!${escape(backtrack)})[^${escape(delimiter)}])`;\n  }\n  return `(?:(?!${escape(backtrack)}|${escape(delimiter)})[\\\\s\\\\S])`;\n}\n/**\n * Stringify token data into a path string.\n */\nfunction stringify(data) {\n  return data.tokens.map(function stringifyToken(token, index, tokens) {\n    if (token.type === \"text\") return escapeText(token.value);\n    if (token.type === \"group\") {\n      return `{${token.tokens.map(stringifyToken).join(\"\")}}`;\n    }\n    const isSafe = isNameSafe(token.name) && isNextNameSafe(tokens[index + 1]);\n    const key = isSafe ? token.name : JSON.stringify(token.name);\n    if (token.type === \"param\") return `:${key}`;\n    if (token.type === \"wildcard\") return `*${key}`;\n    throw new TypeError(`Unexpected token: ${token}`);\n  }).join(\"\");\n}\nfunction isNameSafe(name) {\n  const [first, ...rest] = name;\n  if (!ID_START.test(first)) return false;\n  return rest.every(char => ID_CONTINUE.test(char));\n}\nfunction isNextNameSafe(token) {\n  if ((token === null || token === void 0 ? void 0 : token.type) !== \"text\") return true;\n  return !ID_CONTINUE.test(token.value[0]);\n}","map":{"version":3,"names":["exports","parse","compile","match","pathToRegexp","stringify","DEFAULT_DELIMITER","NOOP_VALUE","value","ID_START","ID_CONTINUE","DEBUG_URL","SIMPLE_TOKENS","escapeText","str","replace","escape","lexer","chars","i","name","test","pos","length","TypeError","type","index","Iter","constructor","tokens","peek","_peek","next","tryConsume","token","undefined","consume","nextType","text","result","TokenData","options","encodePath","it","endType","path","push","param","wildcard","open","encode","encodeURIComponent","delimiter","data","fn","tokensToFunction","missing","join","encoders","map","tokenToFunction","encoder","extras","encodeValue","Array","isArray","decode","decodeURIComponent","regexp","keys","decoders","key","split","input","m","exec","params","Object","create","decoder","end","sensitive","trailing","sources","flags","paths","items","seq","flatten","sequenceToRegExp","pattern","RegExp","init","fork","slice","backtrack","isSafeSegmentParam","includes","negate","stringifyToken","isSafe","isNameSafe","isNextNameSafe","JSON","first","rest","every","char"],"sources":["/Users/linwanjou/Documents/GitHub/SinoPac_Sign_Language/永豐產學/App/node_modules/path-to-regexp/src/index.ts"],"sourcesContent":["const DEFAULT_DELIMITER = \"/\";\nconst NOOP_VALUE = (value: string) => value;\nconst ID_START = /^[$_\\p{ID_Start}]$/u;\nconst ID_CONTINUE = /^[$\\u200c\\u200d\\p{ID_Continue}]$/u;\nconst DEBUG_URL = \"https://git.new/pathToRegexpError\";\n\n/**\n * Encode a string into another string.\n */\nexport type Encode = (value: string) => string;\n\n/**\n * Decode a string into another string.\n */\nexport type Decode = (value: string) => string;\n\nexport interface ParseOptions {\n  /**\n   * A function for encoding input strings.\n   */\n  encodePath?: Encode;\n}\n\nexport interface PathToRegexpOptions {\n  /**\n   * Matches the path completely without trailing characters. (default: `true`)\n   */\n  end?: boolean;\n  /**\n   * Allows optional trailing delimiter to match. (default: `true`)\n   */\n  trailing?: boolean;\n  /**\n   * Match will be case sensitive. (default: `false`)\n   */\n  sensitive?: boolean;\n  /**\n   * The default delimiter for segments. (default: `'/'`)\n   */\n  delimiter?: string;\n}\n\nexport interface MatchOptions extends PathToRegexpOptions {\n  /**\n   * Function for decoding strings for params, or `false` to disable entirely. (default: `decodeURIComponent`)\n   */\n  decode?: Decode | false;\n}\n\nexport interface CompileOptions {\n  /**\n   * Function for encoding input strings for output into the path, or `false` to disable entirely. (default: `encodeURIComponent`)\n   */\n  encode?: Encode | false;\n  /**\n   * The default delimiter for segments. (default: `'/'`)\n   */\n  delimiter?: string;\n}\n\ntype TokenType =\n  | \"{\"\n  | \"}\"\n  | \"WILDCARD\"\n  | \"PARAM\"\n  | \"CHAR\"\n  | \"ESCAPED\"\n  | \"END\"\n  // Reserved for use or ambiguous due to past use.\n  | \"(\"\n  | \")\"\n  | \"[\"\n  | \"]\"\n  | \"+\"\n  | \"?\"\n  | \"!\";\n\n/**\n * Tokenizer results.\n */\ninterface LexToken {\n  type: TokenType;\n  index: number;\n  value: string;\n}\n\nconst SIMPLE_TOKENS: Record<string, TokenType> = {\n  // Groups.\n  \"{\": \"{\",\n  \"}\": \"}\",\n  // Reserved.\n  \"(\": \"(\",\n  \")\": \")\",\n  \"[\": \"[\",\n  \"]\": \"]\",\n  \"+\": \"+\",\n  \"?\": \"?\",\n  \"!\": \"!\",\n};\n\n/**\n * Escape text for stringify to path.\n */\nfunction escapeText(str: string) {\n  return str.replace(/[{}()\\[\\]+?!:*]/g, \"\\\\$&\");\n}\n\n/**\n * Escape a regular expression string.\n */\nfunction escape(str: string) {\n  return str.replace(/[.+*?^${}()[\\]|/\\\\]/g, \"\\\\$&\");\n}\n\n/**\n * Tokenize input string.\n */\nfunction* lexer(str: string): Generator<LexToken, LexToken> {\n  const chars = [...str];\n  let i = 0;\n\n  function name() {\n    let value = \"\";\n\n    if (ID_START.test(chars[++i])) {\n      value += chars[i];\n      while (ID_CONTINUE.test(chars[++i])) {\n        value += chars[i];\n      }\n    } else if (chars[i] === '\"') {\n      let pos = i;\n\n      while (i < chars.length) {\n        if (chars[++i] === '\"') {\n          i++;\n          pos = 0;\n          break;\n        }\n\n        if (chars[i] === \"\\\\\") {\n          value += chars[++i];\n        } else {\n          value += chars[i];\n        }\n      }\n\n      if (pos) {\n        throw new TypeError(`Unterminated quote at ${pos}: ${DEBUG_URL}`);\n      }\n    }\n\n    if (!value) {\n      throw new TypeError(`Missing parameter name at ${i}: ${DEBUG_URL}`);\n    }\n\n    return value;\n  }\n\n  while (i < chars.length) {\n    const value = chars[i];\n    const type = SIMPLE_TOKENS[value];\n\n    if (type) {\n      yield { type, index: i++, value };\n    } else if (value === \"\\\\\") {\n      yield { type: \"ESCAPED\", index: i++, value: chars[i++] };\n    } else if (value === \":\") {\n      const value = name();\n      yield { type: \"PARAM\", index: i, value };\n    } else if (value === \"*\") {\n      const value = name();\n      yield { type: \"WILDCARD\", index: i, value };\n    } else {\n      yield { type: \"CHAR\", index: i, value: chars[i++] };\n    }\n  }\n\n  return { type: \"END\", index: i, value: \"\" };\n}\n\nclass Iter {\n  private _peek?: LexToken;\n\n  constructor(private tokens: Generator<LexToken, LexToken>) {}\n\n  peek(): LexToken {\n    if (!this._peek) {\n      const next = this.tokens.next();\n      this._peek = next.value;\n    }\n    return this._peek;\n  }\n\n  tryConsume(type: TokenType): string | undefined {\n    const token = this.peek();\n    if (token.type !== type) return;\n    this._peek = undefined; // Reset after consumed.\n    return token.value;\n  }\n\n  consume(type: TokenType): string {\n    const value = this.tryConsume(type);\n    if (value !== undefined) return value;\n    const { type: nextType, index } = this.peek();\n    throw new TypeError(\n      `Unexpected ${nextType} at ${index}, expected ${type}: ${DEBUG_URL}`,\n    );\n  }\n\n  text(): string {\n    let result = \"\";\n    let value: string | undefined;\n    while ((value = this.tryConsume(\"CHAR\") || this.tryConsume(\"ESCAPED\"))) {\n      result += value;\n    }\n    return result;\n  }\n}\n\n/**\n * Plain text.\n */\nexport interface Text {\n  type: \"text\";\n  value: string;\n}\n\n/**\n * A parameter designed to match arbitrary text within a segment.\n */\nexport interface Parameter {\n  type: \"param\";\n  name: string;\n}\n\n/**\n * A wildcard parameter designed to match multiple segments.\n */\nexport interface Wildcard {\n  type: \"wildcard\";\n  name: string;\n}\n\n/**\n * A set of possible tokens to expand when matching.\n */\nexport interface Group {\n  type: \"group\";\n  tokens: Token[];\n}\n\n/**\n * A token that corresponds with a regexp capture.\n */\nexport type Key = Parameter | Wildcard;\n\n/**\n * A sequence of `path-to-regexp` keys that match capturing groups.\n */\nexport type Keys = Array<Key>;\n\n/**\n * A sequence of path match characters.\n */\nexport type Token = Text | Parameter | Wildcard | Group;\n\n/**\n * Tokenized path instance.\n */\nexport class TokenData {\n  constructor(public readonly tokens: Token[]) {}\n}\n\n/**\n * Parse a string for the raw tokens.\n */\nexport function parse(str: string, options: ParseOptions = {}): TokenData {\n  const { encodePath = NOOP_VALUE } = options;\n  const it = new Iter(lexer(str));\n\n  function consume(endType: TokenType): Token[] {\n    const tokens: Token[] = [];\n\n    while (true) {\n      const path = it.text();\n      if (path) tokens.push({ type: \"text\", value: encodePath(path) });\n\n      const param = it.tryConsume(\"PARAM\");\n      if (param) {\n        tokens.push({\n          type: \"param\",\n          name: param,\n        });\n        continue;\n      }\n\n      const wildcard = it.tryConsume(\"WILDCARD\");\n      if (wildcard) {\n        tokens.push({\n          type: \"wildcard\",\n          name: wildcard,\n        });\n        continue;\n      }\n\n      const open = it.tryConsume(\"{\");\n      if (open) {\n        tokens.push({\n          type: \"group\",\n          tokens: consume(\"}\"),\n        });\n        continue;\n      }\n\n      it.consume(endType);\n      return tokens;\n    }\n  }\n\n  const tokens = consume(\"END\");\n  return new TokenData(tokens);\n}\n\n/**\n * Compile a string to a template function for the path.\n */\nexport function compile<P extends ParamData = ParamData>(\n  path: Path,\n  options: CompileOptions & ParseOptions = {},\n) {\n  const { encode = encodeURIComponent, delimiter = DEFAULT_DELIMITER } =\n    options;\n  const data = path instanceof TokenData ? path : parse(path, options);\n  const fn = tokensToFunction(data.tokens, delimiter, encode);\n\n  return function path(data: P = {} as P) {\n    const [path, ...missing] = fn(data);\n    if (missing.length) {\n      throw new TypeError(`Missing parameters: ${missing.join(\", \")}`);\n    }\n    return path;\n  };\n}\n\nexport type ParamData = Partial<Record<string, string | string[]>>;\nexport type PathFunction<P extends ParamData> = (data?: P) => string;\n\nfunction tokensToFunction(\n  tokens: Token[],\n  delimiter: string,\n  encode: Encode | false,\n) {\n  const encoders = tokens.map((token) =>\n    tokenToFunction(token, delimiter, encode),\n  );\n\n  return (data: ParamData) => {\n    const result: string[] = [\"\"];\n\n    for (const encoder of encoders) {\n      const [value, ...extras] = encoder(data);\n      result[0] += value;\n      result.push(...extras);\n    }\n\n    return result;\n  };\n}\n\n/**\n * Convert a single token into a path building function.\n */\nfunction tokenToFunction(\n  token: Token,\n  delimiter: string,\n  encode: Encode | false,\n): (data: ParamData) => string[] {\n  if (token.type === \"text\") return () => [token.value];\n\n  if (token.type === \"group\") {\n    const fn = tokensToFunction(token.tokens, delimiter, encode);\n\n    return (data) => {\n      const [value, ...missing] = fn(data);\n      if (!missing.length) return [value];\n      return [\"\"];\n    };\n  }\n\n  const encodeValue = encode || NOOP_VALUE;\n\n  if (token.type === \"wildcard\" && encode !== false) {\n    return (data) => {\n      const value = data[token.name];\n      if (value == null) return [\"\", token.name];\n\n      if (!Array.isArray(value) || value.length === 0) {\n        throw new TypeError(`Expected \"${token.name}\" to be a non-empty array`);\n      }\n\n      return [\n        value\n          .map((value, index) => {\n            if (typeof value !== \"string\") {\n              throw new TypeError(\n                `Expected \"${token.name}/${index}\" to be a string`,\n              );\n            }\n\n            return encodeValue(value);\n          })\n          .join(delimiter),\n      ];\n    };\n  }\n\n  return (data) => {\n    const value = data[token.name];\n    if (value == null) return [\"\", token.name];\n\n    if (typeof value !== \"string\") {\n      throw new TypeError(`Expected \"${token.name}\" to be a string`);\n    }\n\n    return [encodeValue(value)];\n  };\n}\n\n/**\n * A match result contains data about the path match.\n */\nexport interface MatchResult<P extends ParamData> {\n  path: string;\n  params: P;\n}\n\n/**\n * A match is either `false` (no match) or a match result.\n */\nexport type Match<P extends ParamData> = false | MatchResult<P>;\n\n/**\n * The match function takes a string and returns whether it matched the path.\n */\nexport type MatchFunction<P extends ParamData> = (path: string) => Match<P>;\n\n/**\n * Supported path types.\n */\nexport type Path = string | TokenData;\n\n/**\n * Transform a path into a match function.\n */\nexport function match<P extends ParamData>(\n  path: Path | Path[],\n  options: MatchOptions & ParseOptions = {},\n): MatchFunction<P> {\n  const { decode = decodeURIComponent, delimiter = DEFAULT_DELIMITER } =\n    options;\n  const { regexp, keys } = pathToRegexp(path, options);\n\n  const decoders = keys.map((key) => {\n    if (decode === false) return NOOP_VALUE;\n    if (key.type === \"param\") return decode;\n    return (value: string) => value.split(delimiter).map(decode);\n  });\n\n  return function match(input: string) {\n    const m = regexp.exec(input);\n    if (!m) return false;\n\n    const path = m[0];\n    const params = Object.create(null);\n\n    for (let i = 1; i < m.length; i++) {\n      if (m[i] === undefined) continue;\n\n      const key = keys[i - 1];\n      const decoder = decoders[i - 1];\n      params[key.name] = decoder(m[i]);\n    }\n\n    return { path, params };\n  };\n}\n\nexport function pathToRegexp(\n  path: Path | Path[],\n  options: PathToRegexpOptions & ParseOptions = {},\n) {\n  const {\n    delimiter = DEFAULT_DELIMITER,\n    end = true,\n    sensitive = false,\n    trailing = true,\n  } = options;\n  const keys: Keys = [];\n  const sources: string[] = [];\n  const flags = sensitive ? \"\" : \"i\";\n  const paths = Array.isArray(path) ? path : [path];\n  const items = paths.map((path) =>\n    path instanceof TokenData ? path : parse(path, options),\n  );\n\n  for (const { tokens } of items) {\n    for (const seq of flatten(tokens, 0, [])) {\n      const regexp = sequenceToRegExp(seq, delimiter, keys);\n      sources.push(regexp);\n    }\n  }\n\n  let pattern = `^(?:${sources.join(\"|\")})`;\n  if (trailing) pattern += `(?:${escape(delimiter)}$)?`;\n  pattern += end ? \"$\" : `(?=${escape(delimiter)}|$)`;\n\n  const regexp = new RegExp(pattern, flags);\n  return { regexp, keys };\n}\n\n/**\n * Flattened token set.\n */\ntype Flattened = Text | Parameter | Wildcard;\n\n/**\n * Generate a flat list of sequence tokens from the given tokens.\n */\nfunction* flatten(\n  tokens: Token[],\n  index: number,\n  init: Flattened[],\n): Generator<Flattened[]> {\n  if (index === tokens.length) {\n    return yield init;\n  }\n\n  const token = tokens[index];\n\n  if (token.type === \"group\") {\n    const fork = init.slice();\n    for (const seq of flatten(token.tokens, 0, fork)) {\n      yield* flatten(tokens, index + 1, seq);\n    }\n  } else {\n    init.push(token);\n  }\n\n  yield* flatten(tokens, index + 1, init);\n}\n\n/**\n * Transform a flat sequence of tokens into a regular expression.\n */\nfunction sequenceToRegExp(tokens: Flattened[], delimiter: string, keys: Keys) {\n  let result = \"\";\n  let backtrack = \"\";\n  let isSafeSegmentParam = true;\n\n  for (let i = 0; i < tokens.length; i++) {\n    const token = tokens[i];\n\n    if (token.type === \"text\") {\n      result += escape(token.value);\n      backtrack += token.value;\n      isSafeSegmentParam ||= token.value.includes(delimiter);\n      continue;\n    }\n\n    if (token.type === \"param\" || token.type === \"wildcard\") {\n      if (!isSafeSegmentParam && !backtrack) {\n        throw new TypeError(`Missing text after \"${token.name}\": ${DEBUG_URL}`);\n      }\n\n      if (token.type === \"param\") {\n        result += `(${negate(delimiter, isSafeSegmentParam ? \"\" : backtrack)}+)`;\n      } else {\n        result += `([\\\\s\\\\S]+)`;\n      }\n\n      keys.push(token);\n      backtrack = \"\";\n      isSafeSegmentParam = false;\n      continue;\n    }\n  }\n\n  return result;\n}\n\nfunction negate(delimiter: string, backtrack: string) {\n  if (backtrack.length < 2) {\n    if (delimiter.length < 2) return `[^${escape(delimiter + backtrack)}]`;\n    return `(?:(?!${escape(delimiter)})[^${escape(backtrack)}])`;\n  }\n  if (delimiter.length < 2) {\n    return `(?:(?!${escape(backtrack)})[^${escape(delimiter)}])`;\n  }\n  return `(?:(?!${escape(backtrack)}|${escape(delimiter)})[\\\\s\\\\S])`;\n}\n\n/**\n * Stringify token data into a path string.\n */\nexport function stringify(data: TokenData) {\n  return data.tokens\n    .map(function stringifyToken(token, index, tokens): string {\n      if (token.type === \"text\") return escapeText(token.value);\n      if (token.type === \"group\") {\n        return `{${token.tokens.map(stringifyToken).join(\"\")}}`;\n      }\n\n      const isSafe =\n        isNameSafe(token.name) && isNextNameSafe(tokens[index + 1]);\n      const key = isSafe ? token.name : JSON.stringify(token.name);\n\n      if (token.type === \"param\") return `:${key}`;\n      if (token.type === \"wildcard\") return `*${key}`;\n      throw new TypeError(`Unexpected token: ${token}`);\n    })\n    .join(\"\");\n}\n\nfunction isNameSafe(name: string) {\n  const [first, ...rest] = name;\n  if (!ID_START.test(first)) return false;\n  return rest.every((char) => ID_CONTINUE.test(char));\n}\n\nfunction isNextNameSafe(token: Token | undefined) {\n  if (token?.type !== \"text\") return true;\n  return !ID_CONTINUE.test(token.value[0]);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}