{"ast":null,"code":"'use strict';\n\n/**\n * Module dependencies.\n */\nvar bytes = require('bytes');\nvar contentType = require('content-type');\nvar typeis = require('type-is');\n\n/**\n * Module exports.\n */\n\nmodule.exports = {\n  getCharset,\n  normalizeOptions\n};\n\n/**\n * Get the charset of a request.\n *\n * @param {object} req\n * @api private\n */\n\nfunction getCharset(req) {\n  try {\n    return (contentType.parse(req).parameters.charset || '').toLowerCase();\n  } catch {\n    return undefined;\n  }\n}\n\n/**\n * Get the simple type checker.\n *\n * @param {string | string[]} type\n * @return {function}\n */\n\nfunction typeChecker(type) {\n  return function checkType(req) {\n    return Boolean(typeis(req, type));\n  };\n}\n\n/**\n * Normalizes the common options for all parsers.\n *\n * @param {object} options options to normalize\n * @param {string | string[] | function} defaultType default content type(s) or a function to determine it\n * @returns {object}\n */\nfunction normalizeOptions(options, defaultType) {\n  if (!defaultType) {\n    // Parsers must define a default content type\n    throw new TypeError('defaultType must be provided');\n  }\n  var inflate = options?.inflate !== false;\n  var limit = typeof options?.limit !== 'number' ? bytes.parse(options?.limit || '100kb') : options?.limit;\n  var type = options?.type || defaultType;\n  var verify = options?.verify || false;\n  if (verify !== false && typeof verify !== 'function') {\n    throw new TypeError('option verify must be function');\n  }\n\n  // create the appropriate type checking function\n  var shouldParse = typeof type !== 'function' ? typeChecker(type) : type;\n  return {\n    inflate,\n    limit,\n    verify,\n    shouldParse\n  };\n}","map":{"version":3,"names":["bytes","require","contentType","typeis","module","exports","getCharset","normalizeOptions","req","parse","parameters","charset","toLowerCase","undefined","typeChecker","type","checkType","Boolean","options","defaultType","TypeError","inflate","limit","verify","shouldParse"],"sources":["/Users/linwanjou/Documents/GitHub/SinoPac_Sign_Language/永豐產學/App/node_modules/body-parser/lib/utils.js"],"sourcesContent":["'use strict'\n\n/**\n * Module dependencies.\n */\n\nvar bytes = require('bytes')\nvar contentType = require('content-type')\nvar typeis = require('type-is')\n\n/**\n * Module exports.\n */\n\nmodule.exports = {\n  getCharset,\n  normalizeOptions\n}\n\n/**\n * Get the charset of a request.\n *\n * @param {object} req\n * @api private\n */\n\nfunction getCharset (req) {\n  try {\n    return (contentType.parse(req).parameters.charset || '').toLowerCase()\n  } catch {\n    return undefined\n  }\n}\n\n/**\n * Get the simple type checker.\n *\n * @param {string | string[]} type\n * @return {function}\n */\n\nfunction typeChecker (type) {\n  return function checkType (req) {\n    return Boolean(typeis(req, type))\n  }\n}\n\n/**\n * Normalizes the common options for all parsers.\n *\n * @param {object} options options to normalize\n * @param {string | string[] | function} defaultType default content type(s) or a function to determine it\n * @returns {object}\n */\nfunction normalizeOptions (options, defaultType) {\n  if (!defaultType) {\n    // Parsers must define a default content type\n    throw new TypeError('defaultType must be provided')\n  }\n\n  var inflate = options?.inflate !== false\n  var limit = typeof options?.limit !== 'number'\n    ? bytes.parse(options?.limit || '100kb')\n    : options?.limit\n  var type = options?.type || defaultType\n  var verify = options?.verify || false\n\n  if (verify !== false && typeof verify !== 'function') {\n    throw new TypeError('option verify must be function')\n  }\n\n  // create the appropriate type checking function\n  var shouldParse = typeof type !== 'function'\n    ? typeChecker(type)\n    : type\n\n  return {\n    inflate,\n    limit,\n    verify,\n    shouldParse\n  }\n}\n"],"mappings":"AAAA,YAAY;;AAEZ;AACA;AACA;AAEA,IAAIA,KAAK,GAAGC,OAAO,CAAC,OAAO,CAAC;AAC5B,IAAIC,WAAW,GAAGD,OAAO,CAAC,cAAc,CAAC;AACzC,IAAIE,MAAM,GAAGF,OAAO,CAAC,SAAS,CAAC;;AAE/B;AACA;AACA;;AAEAG,MAAM,CAACC,OAAO,GAAG;EACfC,UAAU;EACVC;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASD,UAAUA,CAAEE,GAAG,EAAE;EACxB,IAAI;IACF,OAAO,CAACN,WAAW,CAACO,KAAK,CAACD,GAAG,CAAC,CAACE,UAAU,CAACC,OAAO,IAAI,EAAE,EAAEC,WAAW,CAAC,CAAC;EACxE,CAAC,CAAC,MAAM;IACN,OAAOC,SAAS;EAClB;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASC,WAAWA,CAAEC,IAAI,EAAE;EAC1B,OAAO,SAASC,SAASA,CAAER,GAAG,EAAE;IAC9B,OAAOS,OAAO,CAACd,MAAM,CAACK,GAAG,EAAEO,IAAI,CAAC,CAAC;EACnC,CAAC;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASR,gBAAgBA,CAAEW,OAAO,EAAEC,WAAW,EAAE;EAC/C,IAAI,CAACA,WAAW,EAAE;IAChB;IACA,MAAM,IAAIC,SAAS,CAAC,8BAA8B,CAAC;EACrD;EAEA,IAAIC,OAAO,GAAGH,OAAO,EAAEG,OAAO,KAAK,KAAK;EACxC,IAAIC,KAAK,GAAG,OAAOJ,OAAO,EAAEI,KAAK,KAAK,QAAQ,GAC1CtB,KAAK,CAACS,KAAK,CAACS,OAAO,EAAEI,KAAK,IAAI,OAAO,CAAC,GACtCJ,OAAO,EAAEI,KAAK;EAClB,IAAIP,IAAI,GAAGG,OAAO,EAAEH,IAAI,IAAII,WAAW;EACvC,IAAII,MAAM,GAAGL,OAAO,EAAEK,MAAM,IAAI,KAAK;EAErC,IAAIA,MAAM,KAAK,KAAK,IAAI,OAAOA,MAAM,KAAK,UAAU,EAAE;IACpD,MAAM,IAAIH,SAAS,CAAC,gCAAgC,CAAC;EACvD;;EAEA;EACA,IAAII,WAAW,GAAG,OAAOT,IAAI,KAAK,UAAU,GACxCD,WAAW,CAACC,IAAI,CAAC,GACjBA,IAAI;EAER,OAAO;IACLM,OAAO;IACPC,KAAK;IACLC,MAAM;IACNC;EACF,CAAC;AACH","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}