{"ast":null,"code":"/*!\n * body-parser\n * Copyright(c) 2014 Jonathan Ong\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Module dependencies.\n * @private\n */\nvar createError = require('http-errors');\nvar debug = require('debug')('body-parser:urlencoded');\nvar isFinished = require('on-finished').isFinished;\nvar read = require('../read');\nvar typeis = require('type-is');\nvar qs = require('qs');\nvar {\n  getCharset,\n  normalizeOptions\n} = require('../utils');\n\n/**\n * Module exports.\n */\n\nmodule.exports = urlencoded;\n\n/**\n * Create a middleware to parse urlencoded bodies.\n *\n * @param {object} [options]\n * @return {function}\n * @public\n */\n\nfunction urlencoded(options) {\n  var {\n    inflate,\n    limit,\n    verify,\n    shouldParse\n  } = normalizeOptions(options, 'application/x-www-form-urlencoded');\n  var defaultCharset = options?.defaultCharset || 'utf-8';\n  if (defaultCharset !== 'utf-8' && defaultCharset !== 'iso-8859-1') {\n    throw new TypeError('option defaultCharset must be either utf-8 or iso-8859-1');\n  }\n\n  // create the appropriate query parser\n  var queryparse = createQueryParser(options);\n  function parse(body, encoding) {\n    return body.length ? queryparse(body, encoding) : {};\n  }\n  return function urlencodedParser(req, res, next) {\n    if (isFinished(req)) {\n      debug('body already parsed');\n      next();\n      return;\n    }\n    if (!('body' in req)) {\n      req.body = undefined;\n    }\n\n    // skip requests without bodies\n    if (!typeis.hasBody(req)) {\n      debug('skip empty body');\n      next();\n      return;\n    }\n    debug('content-type %j', req.headers['content-type']);\n\n    // determine if request should be parsed\n    if (!shouldParse(req)) {\n      debug('skip parsing');\n      next();\n      return;\n    }\n\n    // assert charset\n    var charset = getCharset(req) || defaultCharset;\n    if (charset !== 'utf-8' && charset !== 'iso-8859-1') {\n      debug('invalid charset');\n      next(createError(415, 'unsupported charset \"' + charset.toUpperCase() + '\"', {\n        charset: charset,\n        type: 'charset.unsupported'\n      }));\n      return;\n    }\n\n    // read\n    read(req, res, next, parse, debug, {\n      encoding: charset,\n      inflate,\n      limit,\n      verify\n    });\n  };\n}\n\n/**\n * Get the extended query parser.\n *\n * @param {object} options\n */\n\nfunction createQueryParser(options) {\n  var extended = Boolean(options?.extended);\n  var parameterLimit = options?.parameterLimit !== undefined ? options?.parameterLimit : 1000;\n  var charsetSentinel = options?.charsetSentinel;\n  var interpretNumericEntities = options?.interpretNumericEntities;\n  var depth = extended ? options?.depth !== undefined ? options?.depth : 32 : 0;\n  if (isNaN(parameterLimit) || parameterLimit < 1) {\n    throw new TypeError('option parameterLimit must be a positive number');\n  }\n  if (isNaN(depth) || depth < 0) {\n    throw new TypeError('option depth must be a zero or a positive number');\n  }\n  if (isFinite(parameterLimit)) {\n    parameterLimit = parameterLimit | 0;\n  }\n  return function queryparse(body, encoding) {\n    var paramCount = parameterCount(body, parameterLimit);\n    if (paramCount === undefined) {\n      debug('too many parameters');\n      throw createError(413, 'too many parameters', {\n        type: 'parameters.too.many'\n      });\n    }\n    var arrayLimit = extended ? Math.max(100, paramCount) : 0;\n    debug('parse ' + (extended ? 'extended ' : '') + 'urlencoding');\n    try {\n      return qs.parse(body, {\n        allowPrototypes: true,\n        arrayLimit: arrayLimit,\n        depth: depth,\n        charsetSentinel: charsetSentinel,\n        interpretNumericEntities: interpretNumericEntities,\n        charset: encoding,\n        parameterLimit: parameterLimit,\n        strictDepth: true\n      });\n    } catch (err) {\n      if (err instanceof RangeError) {\n        throw createError(400, 'The input exceeded the depth', {\n          type: 'querystring.parse.rangeError'\n        });\n      } else {\n        throw err;\n      }\n    }\n  };\n}\n\n/**\n * Count the number of parameters, stopping once limit reached\n *\n * @param {string} body\n * @param {number} limit\n * @api private\n */\n\nfunction parameterCount(body, limit) {\n  var len = body.split('&').length;\n  return len > limit ? undefined : len - 1;\n}","map":{"version":3,"names":["createError","require","debug","isFinished","read","typeis","qs","getCharset","normalizeOptions","module","exports","urlencoded","options","inflate","limit","verify","shouldParse","defaultCharset","TypeError","queryparse","createQueryParser","parse","body","encoding","length","urlencodedParser","req","res","next","undefined","hasBody","headers","charset","toUpperCase","type","extended","Boolean","parameterLimit","charsetSentinel","interpretNumericEntities","depth","isNaN","isFinite","paramCount","parameterCount","arrayLimit","Math","max","allowPrototypes","strictDepth","err","RangeError","len","split"],"sources":["/Users/linwanjou/Documents/GitHub/SinoPac_Sign_Language/永豐產學/App/node_modules/body-parser/lib/types/urlencoded.js"],"sourcesContent":["/*!\n * body-parser\n * Copyright(c) 2014 Jonathan Ong\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar createError = require('http-errors')\nvar debug = require('debug')('body-parser:urlencoded')\nvar isFinished = require('on-finished').isFinished\nvar read = require('../read')\nvar typeis = require('type-is')\nvar qs = require('qs')\nvar { getCharset, normalizeOptions } = require('../utils')\n\n/**\n * Module exports.\n */\n\nmodule.exports = urlencoded\n\n/**\n * Create a middleware to parse urlencoded bodies.\n *\n * @param {object} [options]\n * @return {function}\n * @public\n */\n\nfunction urlencoded (options) {\n  var { inflate, limit, verify, shouldParse } = normalizeOptions(options, 'application/x-www-form-urlencoded')\n\n  var defaultCharset = options?.defaultCharset || 'utf-8'\n  if (defaultCharset !== 'utf-8' && defaultCharset !== 'iso-8859-1') {\n    throw new TypeError('option defaultCharset must be either utf-8 or iso-8859-1')\n  }\n\n  // create the appropriate query parser\n  var queryparse = createQueryParser(options)\n\n  function parse (body, encoding) {\n    return body.length\n      ? queryparse(body, encoding)\n      : {}\n  }\n\n  return function urlencodedParser (req, res, next) {\n    if (isFinished(req)) {\n      debug('body already parsed')\n      next()\n      return\n    }\n\n    if (!('body' in req)) {\n      req.body = undefined\n    }\n\n    // skip requests without bodies\n    if (!typeis.hasBody(req)) {\n      debug('skip empty body')\n      next()\n      return\n    }\n\n    debug('content-type %j', req.headers['content-type'])\n\n    // determine if request should be parsed\n    if (!shouldParse(req)) {\n      debug('skip parsing')\n      next()\n      return\n    }\n\n    // assert charset\n    var charset = getCharset(req) || defaultCharset\n    if (charset !== 'utf-8' && charset !== 'iso-8859-1') {\n      debug('invalid charset')\n      next(createError(415, 'unsupported charset \"' + charset.toUpperCase() + '\"', {\n        charset: charset,\n        type: 'charset.unsupported'\n      }))\n      return\n    }\n\n    // read\n    read(req, res, next, parse, debug, {\n      encoding: charset,\n      inflate,\n      limit,\n      verify\n    })\n  }\n}\n\n/**\n * Get the extended query parser.\n *\n * @param {object} options\n */\n\nfunction createQueryParser (options) {\n  var extended = Boolean(options?.extended)\n  var parameterLimit = options?.parameterLimit !== undefined\n    ? options?.parameterLimit\n    : 1000\n  var charsetSentinel = options?.charsetSentinel\n  var interpretNumericEntities = options?.interpretNumericEntities\n  var depth = extended ? (options?.depth !== undefined ? options?.depth : 32) : 0\n\n  if (isNaN(parameterLimit) || parameterLimit < 1) {\n    throw new TypeError('option parameterLimit must be a positive number')\n  }\n\n  if (isNaN(depth) || depth < 0) {\n    throw new TypeError('option depth must be a zero or a positive number')\n  }\n\n  if (isFinite(parameterLimit)) {\n    parameterLimit = parameterLimit | 0\n  }\n\n  return function queryparse (body, encoding) {\n    var paramCount = parameterCount(body, parameterLimit)\n\n    if (paramCount === undefined) {\n      debug('too many parameters')\n      throw createError(413, 'too many parameters', {\n        type: 'parameters.too.many'\n      })\n    }\n\n    var arrayLimit = extended ? Math.max(100, paramCount) : 0\n\n    debug('parse ' + (extended ? 'extended ' : '') + 'urlencoding')\n    try {\n      return qs.parse(body, {\n        allowPrototypes: true,\n        arrayLimit: arrayLimit,\n        depth: depth,\n        charsetSentinel: charsetSentinel,\n        interpretNumericEntities: interpretNumericEntities,\n        charset: encoding,\n        parameterLimit: parameterLimit,\n        strictDepth: true\n      })\n    } catch (err) {\n      if (err instanceof RangeError) {\n        throw createError(400, 'The input exceeded the depth', {\n          type: 'querystring.parse.rangeError'\n        })\n      } else {\n        throw err\n      }\n    }\n  }\n}\n\n/**\n * Count the number of parameters, stopping once limit reached\n *\n * @param {string} body\n * @param {number} limit\n * @api private\n */\n\nfunction parameterCount (body, limit) {\n  var len = body.split('&').length\n\n  return len > limit ? undefined : len - 1\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}